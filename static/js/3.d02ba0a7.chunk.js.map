{"version":3,"sources":["components/Settings/Export/Export.helpers.js"],"names":["pdfMake","vfs","pdfFonts","imageElement","Image","toSnakeCase","str","value","replace","$1","toLowerCase","startsWith","slice","getOBFButtonProps","tile","intl","button","tileExtProps","CBOARD_EXT_PROPERTIES","filter","key","forEach","keyWithPrefix","CBOARD_EXT_PREFIX","label","labelKey","length","formatMessage","id","action","vocalization","borderColor","backgroundColor","getBase64Image","base64Str","split","prefix","base64Data","contentType","byteString","atob","ab","ArrayBuffer","ia","Uint8Array","i","charCodeAt","data","content_type","getDataUri","url","a","axios","method","responseType","result","encodedImage","btoa","reduce","byte","String","fromCharCode","headers","console","error","boardToOBF","boardsMap","board","embed","tiles","obf","images","fetchedImages","grid","Array","Math","ceil","CBOARD_COLUMNS","currentRow","Promise","all","map","push","image","isCordova","search","imageResponse","getCustomImagePath","components","name","nameKey","extension","mime","_","path","imageID","mongoose","Types","ObjectId","toString","undefined","width","height","loadBoard","loadBoardData","buttons","lastGridRowDiff","emptyButtons","concat","format","locale","CBOARD_OBF_CONSTANTS","URL","license","LICENSE","Object","values","sounds","rows","columns","order","description_html","getPDFTileData","toDataURL","styles","outputFormat","resolve","reject","crossOrigin","onload","canvas","document","createElement","ctx","getContext","fillStyle","fillRect","strokeStyle","lineWidth","strokeRect","widthFix","heightFix","this","naturalWidth","naturalHeight","drawImage","dataURL","onerror","Error","imageUrl","src","EMPTY_IMAGE","complete","generatePDFBoard","breakPage","header","isFixed","CBOARD_ROWS","table","widths","body","layout","pageBreak","generateFixedBoard","generateNonFixedBoard","emptyCells","fill","chunks","array","size","newArray","results","splice","cont","defaultTile","itemsPerPage","pages","pageIndex","items","utils","rowIndex","columnIndex","tileId","find","addTileToGrid","prev","fixedRow","imageData","log","message","NOT_FOUND_IMAGE","alignment","labelData","text","fontSize","displaySettings","getDisplaySettings","value2","labelPosition","LABEL_POSITION_BELOW","value1","LABEL_POSITION_ABOVE","getStore","getState","app","getDatetimePrefix","moment","openboardExportAdapter","boardOrBoards","openboardExportManyAdapter","openboardExportOneAdapter","content","Blob","JSON","stringify","type","isAndroid","requestCvaWritePermissions","writeCvaFile","saveAs","boards","boardsLength","boardsForManifest","imagesMap","zip","JSZip","current","boardMapFilename","file","keys","imageFilename","root","manifest","paths","generateAsync","CBOARD_ZIP_OPTIONS","then","EXPORT_CONFIG_BY_TYPE","openboard","filename","getNestedBoards","allBoards","rootBoardId","b","unseen","nestedBoardIds","curr","pop","cboardExportAdapter","jsonData","cboard","navigator","msSaveBlob","link","href","window","createObjectURL","setAttribute","appendChild","click","removeChild","pdfExportAdapter","docDefinition","pageSize","pageOrientation","pageMargins","lastBoardIndex","prevContent","boardPDFData","pdfObj","createPdf","getBuffer","buffer","blob","pdf","download"],"mappings":"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","file":"static/js/3.d02ba0a7.chunk.js","sourcesContent":["import JSZip from 'jszip';\nimport axios from 'axios';\nimport moment from 'moment';\nimport pdfMake from 'pdfmake/build/pdfmake';\nimport pdfFonts from 'pdfmake/build/vfs_fonts';\nimport { saveAs } from 'file-saver';\nimport {\n  EXPORT_CONFIG_BY_TYPE,\n  CBOARD_OBF_CONSTANTS,\n  CBOARD_COLUMNS,\n  CBOARD_ROWS,\n  CBOARD_EXT_PREFIX,\n  CBOARD_EXT_PROPERTIES,\n  CBOARD_ZIP_OPTIONS,\n  NOT_FOUND_IMAGE,\n  EMPTY_IMAGE\n} from './Export.constants';\nimport {\n  LABEL_POSITION_ABOVE,\n  LABEL_POSITION_BELOW\n} from '../Display/Display.constants';\nimport {\n  isAndroid,\n  isCordova,\n  requestCvaWritePermissions,\n  writeCvaFile\n} from '../../../cordova-util';\nimport { getStore } from '../../../store';\nimport * as _ from 'lodash';\nimport mime from 'mime-types';\nimport mongoose from 'mongoose';\nimport * as utils from '../../../components/FixedGrid/utils';\n\npdfMake.vfs = pdfFonts.pdfMake.vfs;\n\nconst imageElement = new Image();\n\nfunction toSnakeCase(str) {\n  const value = str.replace(/([A-Z])/g, $1 => '_' + $1.toLowerCase());\n  return value.startsWith('_') ? value.slice(1) : value;\n}\n\nfunction getOBFButtonProps(tile = {}, intl) {\n  const button = {};\n\n  const tileExtProps = CBOARD_EXT_PROPERTIES.filter(key => !!tile[key]);\n  tileExtProps.forEach(key => {\n    const keyWithPrefix = `${CBOARD_EXT_PREFIX}${toSnakeCase(key)}`;\n    button[keyWithPrefix] = tile[key];\n  });\n\n  const label = tile.label || tile.labelKey || '';\n  button.label = label.length ? intl.formatMessage({ id: label }) : label;\n\n  if (tile.action) {\n    button.action = tile.action;\n  }\n\n  if (tile.vocalization) {\n    button.vocalization = tile.vocalization;\n  }\n\n  if (tile.borderColor) {\n    button['border_color'] = tile.borderColor;\n  }\n\n  if (tile.backgroundColor) {\n    button['background_color'] = tile.backgroundColor;\n  }\n\n  return button;\n}\n\nfunction getBase64Image(base64Str = '') {\n  const [prefix, base64Data] = base64Str.split(',');\n  const contentType = prefix.split(':')[1].split(';')[0];\n  const byteString = atob(base64Data);\n\n  // https://gist.github.com/fupslot/5015897\n  const ab = new ArrayBuffer(byteString.length);\n  const ia = new Uint8Array(ab);\n  for (var i = 0; i < byteString.length; i++) {\n    ia[i] = byteString.charCodeAt(i);\n  }\n\n  return {\n    ab,\n    data: base64Str,\n    content_type: contentType\n  };\n}\n\nexport async function getDataUri(url) {\n  try {\n    const result = await axios({\n      method: 'get',\n      url,\n      responseType: 'arraybuffer'\n    });\n\n    // Convert the array buffer to a Base64-encoded string.\n    const encodedImage = btoa(\n      new Uint8Array(result.data).reduce(\n        (data, byte) => data + String.fromCharCode(byte),\n        ''\n      )\n    );\n    const contentType = result.headers['content-type'];\n\n    return {\n      ab: result.data,\n      content_type: contentType,\n      data: `data:${contentType};base64,${encodedImage}`\n    };\n  } catch (e) {\n    console.error(`Failed to get image at ${url}.`, e);\n  }\n}\n\n/**\n * Generate the contents of an OBF file for a single board, and get the\n * associated images.\n *\n * @param boardsMap A map of boards by id.\n * @param board The board to export.\n * @param intl\n * @param embed Whether or not to embed images directly in the OBF file. Should\n *              be true when we're exporting a single board, as we won't generate\n *              an OBZ archive.\n */\n// TODO: Embed sounds as well.\nasync function boardToOBF(boardsMap, board = {}, intl, { embed = false }) {\n  if (!board.tiles || board.tiles.length < 1) {\n    return { obf: null, images: null };\n  }\n\n  const images = {};\n  const fetchedImages = {};\n  const grid = new Array(Math.ceil(board.tiles.length / CBOARD_COLUMNS));\n  let currentRow = 0;\n  const buttons = await Promise.all(\n    board.tiles.map(async (tile, i) => {\n      currentRow =\n        i >= (currentRow + 1) * CBOARD_COLUMNS ? currentRow + 1 : currentRow;\n\n      if (tile) {\n        if (grid[currentRow]) {\n          grid[currentRow].push(tile.id);\n        } else {\n          grid[currentRow] = [tile.id];\n        }\n\n        const button = {\n          id: tile.id,\n          ...getOBFButtonProps(tile, intl)\n        };\n\n        if (tile.image && tile.image.length) {\n          // Cordova path cannot be absolute\n          const image =\n            isCordova() && tile.image && tile.image.search('/') === 0\n              ? `.${tile.image}`\n              : tile.image;\n\n          const imageResponse = image.startsWith('data:')\n            ? getBase64Image(image)\n            : await getDataUri(image);\n\n          const getCustomImagePath = () => {\n            const components = [\n              'custom',\n              board.name || board.nameKey,\n              tile.label || tile.labelKey || tile.id\n            ];\n            const extension = mime.extension(imageResponse['content_type']);\n            return `/${_.join(components, '/')}.${extension}`;\n          };\n\n          const path = image.startsWith('data:')\n            ? getCustomImagePath()\n            : isCordova()\n            ? ''\n            : image.startsWith('/')\n            ? image\n            : `/${image}`;\n\n          if (imageResponse) {\n            const imageID = new mongoose.Types.ObjectId().toString();\n            fetchedImages[imageID] = _.defaults({ path }, imageResponse);\n            button['image_id'] = imageID;\n            images[imageID] = {\n              id: imageID,\n              // If images are embedded and we're generating a single OBF\n              // file, the path is unnecessary.\n              path: embed ? undefined : path,\n              data: embed ? imageResponse.data : undefined,\n              content_type: imageResponse['content_type'],\n              width: 300,\n              height: 300\n            };\n          }\n        }\n\n        if (tile.loadBoard && boardsMap[tile.loadBoard]) {\n          const loadBoardData = boardsMap[tile.loadBoard];\n          button['load_board'] = {\n            name: loadBoardData.nameKey\n              ? intl.formatMessage({ id: loadBoardData.nameKey })\n              : '',\n            path: `boards/${tile.loadBoard}.obf`\n          };\n        }\n\n        return button;\n      }\n    })\n  );\n\n  if (grid.length >= 1) {\n    const lastGridRowDiff = CBOARD_COLUMNS - grid[grid.length - 1].length;\n    if (lastGridRowDiff > 0) {\n      const emptyButtons = new Array(lastGridRowDiff).map(() => null);\n      grid[grid.length - 1] = grid[grid.length - 1].concat(emptyButtons);\n    }\n\n    const obf = {\n      format: 'open-board-0.1',\n      id: board.id,\n      locale: intl.locale,\n      name: board.name,\n      url: `${CBOARD_OBF_CONSTANTS.URL}${board.id}`,\n      license: CBOARD_OBF_CONSTANTS.LICENSE,\n      images: Object.values(images),\n      buttons,\n      sounds: [],\n      grid: {\n        rows: grid.length,\n        columns: CBOARD_COLUMNS,\n        order: grid\n      },\n      description_html: board.nameKey\n        ? intl.formatMessage({ id: board.nameKey })\n        : ''\n    };\n\n    const boardExtProps = CBOARD_EXT_PROPERTIES.filter(\n      key => typeof board[key] !== 'undefined'\n    );\n    boardExtProps.forEach(key => {\n      const keyWithPrefix = `${CBOARD_EXT_PREFIX}${toSnakeCase(key)}`;\n      obf[keyWithPrefix] = board[key];\n    });\n\n    return { obf, images: fetchedImages };\n  } else {\n    return { obf: null, images: null };\n  }\n}\n\nfunction getPDFTileData(tile, intl) {\n  const label = tile.label || tile.labelKey || '';\n  return {\n    label: label.length ? intl.formatMessage({ id: label }) : label,\n    image: tile.image || ''\n  };\n}\n\nasync function toDataURL(url, styles = {}, outputFormat = 'image/jpeg') {\n  return new Promise((resolve, reject) => {\n    imageElement.crossOrigin = 'Anonymous';\n    imageElement.onload = function() {\n      const canvas = document.createElement('CANVAS');\n      const ctx = canvas.getContext('2d');\n      const backgroundColor = styles.backgroundColor || 'white';\n      const borderColor = styles.borderColor || null;\n      canvas.height = 150;\n      canvas.width = 150;\n\n      ctx.fillStyle = backgroundColor;\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n      if (borderColor) {\n        ctx.strokeStyle = borderColor;\n        ctx.lineWidth = 2;\n        ctx.strokeRect(0, 0, canvas.width, canvas.height);\n      }\n\n      let widthFix = 1;\n      let heightFix = 1;\n      const needToScale = this.naturalWidth > 150 || this.naturalHeight > 150;\n      if (needToScale) {\n        widthFix = 150 / this.naturalWidth;\n        heightFix = 150 / this.naturalHeight;\n      }\n\n      ctx.drawImage(\n        this,\n        0,\n        0,\n        this.naturalWidth * widthFix,\n        this.naturalHeight * heightFix\n      );\n\n      if (borderColor) {\n        ctx.strokeStyle = borderColor;\n        ctx.lineWidth = 3;\n        ctx.strokeRect(0, 0, 150, 150);\n      }\n      const dataURL = canvas.toDataURL(outputFormat);\n      resolve(dataURL);\n    };\n    imageElement.onerror = function() {\n      reject(new Error('Getting remote image failed'));\n    };\n    // Cordova path cannot be absolute\n    const imageUrl =\n      isCordova() && url && url.search('/') === 0 ? `.${url}` : url;\n    if (url) {\n      imageElement.src = imageUrl;\n    } else {\n      imageElement.src = EMPTY_IMAGE;\n    }\n    if (imageElement.complete || imageElement.complete === undefined) {\n      if (url) {\n        imageElement.src = imageUrl;\n      } else {\n        imageElement.src = EMPTY_IMAGE;\n      }\n    }\n  });\n}\n\nasync function generatePDFBoard(board, intl, breakPage = true) {\n  const header = board.name || '';\n  const columns =\n    board.isFixed && board.grid ? board.grid.columns : CBOARD_COLUMNS;\n  const rows = board.isFixed && board.grid ? board.grid.rows : CBOARD_ROWS;\n  const table = {\n    table: {\n      widths: '*',\n      body: [{}]\n    },\n    layout: 'noBorders'\n  };\n\n  if (breakPage) {\n    table.pageBreak = 'after';\n  }\n\n  if (!board.tiles || !board.tiles.length) {\n    return [header, table];\n  }\n\n  const grid = board.isFixed\n    ? await generateFixedBoard(board, rows, columns, intl, table)\n    : await generateNonFixedBoard(board, rows, columns, intl, table);\n\n  const lastGridRowDiff = columns - grid[grid.length - 2].length; // labels row\n  if (lastGridRowDiff > 0) {\n    const emptyCells = new Array(lastGridRowDiff).fill('');\n    grid[grid.length - 2] = grid[grid.length - 2].concat(emptyCells); // labels\n    grid[grid.length - 1] = grid[grid.length - 1].concat(emptyCells); // images\n  }\n\n  table.table.body = grid;\n\n  return [header, table];\n}\n\nfunction chunks(array, size) {\n  const newArray = [...array];\n  const results = [];\n\n  while (newArray.length) {\n    results.push(newArray.splice(0, size));\n  }\n\n  return results;\n}\n\nasync function generateFixedBoard(board, rows, columns, intl) {\n  let currentRow = 0;\n  let cont = 0;\n\n  const defaultTile = {\n    label: '',\n    labelKey: '',\n    image: '',\n    backgroundColor: '#d9d9d9'\n  };\n\n  const itemsPerPage = rows * columns;\n  const pages = chunks(board.tiles, itemsPerPage);\n  const grid = new Array(board.grid.rows * 2 * pages.length);\n\n  for (let pageIndex = 0; pageIndex < pages.length; pageIndex++) {\n    const items = pages[pageIndex];\n    const order = utils.getNewOrder({\n      columns,\n      rows,\n      order: board.grid.order,\n      items\n    });\n    for (let rowIndex = 0; rowIndex < order.length; rowIndex++) {\n      for (\n        let columnIndex = 0;\n        columnIndex < order[rowIndex].length;\n        columnIndex++\n      ) {\n        const tileId = order[rowIndex][columnIndex];\n        let tile = board.tiles.find(tile => tile.id === tileId);\n        if (tile === undefined) {\n          tile = defaultTile;\n        }\n        currentRow =\n          cont >= (currentRow + 1) * columns ? currentRow + 1 : currentRow;\n        let pageBreak = false;\n        if (\n          (currentRow + 1) % rows === 0 &&\n          pages.length > 0 &&\n          currentRow + 1 < pages.length * rows\n        ) {\n          pageBreak = true;\n        }\n\n        await addTileToGrid(\n          tile,\n          intl,\n          grid,\n          rows,\n          columns,\n          currentRow,\n          pageBreak\n        );\n        cont++;\n      }\n    }\n  }\n  return grid;\n}\n\nasync function generateNonFixedBoard(board, rows, columns, intl) {\n  // Do a grid with 2n rows\n  const grid = new Array(Math.ceil(board.tiles.length / columns) * 2);\n  let currentRow = 0;\n\n  await board.tiles.reduce(async (prev, tile, i) => {\n    // Wait for previous tile\n    await prev;\n    currentRow = i >= (currentRow + 1) * columns ? currentRow + 1 : currentRow;\n    return await addTileToGrid(tile, intl, grid, rows, columns, currentRow);\n  }, Promise.resolve());\n  return grid;\n}\n\nconst addTileToGrid = async (\n  tile,\n  intl,\n  grid,\n  rows,\n  columns,\n  currentRow,\n  pageBreak = false\n) => {\n  const { label, image } = getPDFTileData(tile, intl);\n  const fixedRow = currentRow * 2;\n  let imageData = '';\n  let dataURL = image;\n  if (\n    !image.startsWith('data:') ||\n    image.startsWith('data:image/svg+xml') ||\n    image.startsWith('data:image/png')\n  ) {\n    let url = image;\n    const styles = {};\n    if (tile.backgroundColor) {\n      styles.backgroundColor = tile.backgroundColor;\n    }\n    if (tile.borderColor) {\n      styles.borderColor = tile.borderColor;\n    }\n    try {\n      dataURL = await toDataURL(url, styles);\n    } catch (err) {\n      console.log(err.message);\n      dataURL = NOT_FOUND_IMAGE;\n    }\n  }\n  imageData = {\n    image: dataURL,\n    alignment: 'center',\n    width: '100'\n  };\n\n  const labelData = {\n    text: label,\n    alignment: 'center'\n  };\n\n  if (11 === columns || columns === 12 || rows >= 6) {\n    imageData.width = '59';\n    labelData.fontSize = 9;\n  } else if (9 === columns || columns === 10 || rows === 5) {\n    imageData.width = '70';\n  } else if (7 === columns || columns === 8) {\n    imageData.width = '90';\n  }\n\n  const displaySettings = getDisplaySettings();\n  let value1,\n    value2 = {};\n  if (\n    displaySettings.labelPosition &&\n    displaySettings.labelPosition === LABEL_POSITION_BELOW\n  ) {\n    value1 = imageData;\n    value2 = labelData;\n  } else if (\n    displaySettings.labelPosition &&\n    displaySettings.labelPosition === LABEL_POSITION_ABOVE\n  ) {\n    value2 = imageData;\n    value1 = labelData;\n  } else {\n    // Add an empty label to have more vertical space between tiles.\n    value1 = { text: ' ' };\n    value2 = imageData;\n  }\n\n  // Add a page break when we reach the maximum number of rows on the\n  // current page.\n  if (pageBreak) {\n    value2.pageBreak = 'after';\n  }\n\n  if (grid[fixedRow]) {\n    grid[fixedRow].push(value1);\n    grid[fixedRow + 1].push(value2);\n  } else {\n    grid[fixedRow] = [value1];\n    grid[fixedRow + 1] = [value2];\n  }\n  return grid;\n};\n\nconst getDisplaySettings = () => {\n  const store = getStore();\n  const {\n    app: { displaySettings }\n  } = store.getState();\n\n  return displaySettings;\n};\n\n/**\n * Get a filename prefix with the current date and time.\n */\nconst getDatetimePrefix = () => moment().format('YYYY-MM-DD_HH-mm-ss-');\n\n/**\n * Export one or several boards in the Open Board Format. If we specifically\n * want to export a single board, we generate a single OBF file, otherwise\n * we generate an OBZ archive.\n *\n * @param boardOrBoards A board, or an array of boards.\n * @param intl\n * @returns {Promise<void>} Nothing.\n */\nexport async function openboardExportAdapter(boardOrBoards, intl) {\n  return _.isArray(boardOrBoards)\n    ? openboardExportManyAdapter(boardOrBoards, intl)\n    : openboardExportOneAdapter(boardOrBoards, intl);\n}\n\nexport async function openboardExportOneAdapter(board, intl) {\n  const { obf } = await boardToOBF({ [board.id]: board }, board, intl, {\n    embed: true\n  });\n  const content = new Blob([JSON.stringify(obf, null, 2)], {\n    type: 'application/json'\n  });\n\n  if (content) {\n    // TODO: Remove illegal characters from the board name.\n    const prefix = getDatetimePrefix() + board.name + ' ';\n    if (isAndroid()) {\n      requestCvaWritePermissions();\n      writeCvaFile('Download/' + prefix + 'board.obf', content);\n    } else {\n      saveAs(content, prefix + 'board.obf');\n    }\n  }\n}\n\nexport async function openboardExportManyAdapter(boards = [], intl) {\n  const boardsLength = boards.length;\n  const boardsForManifest = {};\n  const imagesMap = {};\n  const zip = new JSZip();\n\n  const boardsMap = boards.reduce((prev, current) => {\n    prev[current.id] = current;\n    return prev;\n  }, {});\n\n  for (let i = 0; i < boardsLength; i++) {\n    const board = boards[i];\n    const boardMapFilename = `boards/${board.id}.obf`;\n    const { obf, images } = await boardToOBF(boardsMap, board, intl, {\n      embed: false\n    });\n\n    if (!obf) {\n      continue;\n    }\n\n    zip.file(boardMapFilename, JSON.stringify(obf, null, 2));\n\n    const imagesKeys = Object.keys(images);\n    imagesKeys.forEach(key => {\n      const image = images[key];\n      const imageFilename = `images/${image.path}`;\n      zip.file(imageFilename, image.ab);\n      imagesMap[key] = imageFilename;\n    });\n\n    boardsForManifest[board.id] = boardMapFilename;\n  }\n\n  const root = boardsForManifest.root\n    ? boardsForManifest.root\n    : boardsForManifest[Object.keys(boardsMap)[0]];\n\n  const manifest = {\n    format: 'open-board-0.1',\n    root,\n    paths: {\n      boards: boardsForManifest,\n      images: imagesMap\n    }\n  };\n\n  zip.file('manifest.json', JSON.stringify(manifest, null, 2));\n\n  zip.generateAsync(CBOARD_ZIP_OPTIONS).then(content => {\n    if (content) {\n      let prefix = getDatetimePrefix();\n      if (boards.length === 1) {\n        prefix = prefix + boards[0].name + ' ';\n      } else {\n        prefix = prefix + 'boardsset ';\n      }\n      if (isAndroid()) {\n        requestCvaWritePermissions();\n        const name =\n          'Download/' + prefix + EXPORT_CONFIG_BY_TYPE.openboard.filename;\n        writeCvaFile(name, content);\n      } else {\n        saveAs(content, prefix + EXPORT_CONFIG_BY_TYPE.openboard.filename);\n      }\n    }\n  });\n}\n\n/**\n * For a given board, get the board and its subfolders. For example,\n * for the following structure and the root board A:\n *\n *     A\n *    / \\\n *   B  C\n *     / \\\n *    D   E\n *\n * The output should contain boards A, B, C, D, and E.\n *\n * @param allBoards An array of boards.\n * @param rootBoardId The id of the \"main\" board that we want to export.\n * @returns {Array<Object>} The board and its subfolders.\n */\nfunction getNestedBoards(allBoards, rootBoardId) {\n  const boardsMap = _.fromPairs(_.map(allBoards, b => [b.id, b]));\n\n  const unseen = [rootBoardId];\n  const nestedBoardIds = [rootBoardId];\n\n  while (!_.isEmpty(unseen)) {\n    const curr = unseen.pop();\n    const tiles = _.get(boardsMap[curr], 'tiles');\n    _.forEach(tiles, tile => {\n      const id = tile.loadBoard;\n      // The second check is necessary to handle cycles (for example,\n      // A -> B -> A).\n      if (id && !_.includes(nestedBoardIds, id)) {\n        nestedBoardIds.push(id);\n        unseen.push(id);\n      }\n    });\n  }\n\n  return _.map(nestedBoardIds, id => boardsMap[id]);\n}\n\nexport async function cboardExportAdapter(allBoards = [], board) {\n  const boards = board ? getNestedBoards(allBoards, board.id) : allBoards;\n\n  const jsonData = new Blob([JSON.stringify(boards)], {\n    type: 'text/json;charset=utf-8;'\n  });\n\n  if (jsonData) {\n    let prefix = getDatetimePrefix();\n    if (boards.length === 1) {\n      prefix = prefix + boards[0].name + ' ';\n    } else {\n      prefix = prefix + 'boardsset ';\n    }\n    if (isAndroid()) {\n      requestCvaWritePermissions();\n      const name = 'Download/' + prefix + EXPORT_CONFIG_BY_TYPE.cboard.filename;\n      writeCvaFile(name, jsonData);\n    }\n    // TODO: Can we use `saveAs` here, like in the other adapters?\n    // IE11 & Edge\n    if (navigator.msSaveBlob) {\n      navigator.msSaveBlob(\n        jsonData,\n        prefix + EXPORT_CONFIG_BY_TYPE.cboard.filename\n      );\n    } else {\n      // In FF link must be added to DOM to be clicked\n      const link = document.createElement('a');\n      link.href = window.URL.createObjectURL(jsonData);\n      link.setAttribute(\n        'download',\n        prefix + EXPORT_CONFIG_BY_TYPE.cboard.filename\n      );\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n    }\n  }\n}\n\nexport async function pdfExportAdapter(boards = [], intl) {\n  const docDefinition = {\n    pageSize: 'A4',\n    pageOrientation: 'landscape',\n    pageMargins: [20, 20],\n    content: []\n  };\n  const lastBoardIndex = boards.length - 1;\n  const content = await boards.reduce(async (prev, board, i) => {\n    const prevContent = await prev;\n    const breakPage = i !== lastBoardIndex;\n    const boardPDFData = await generatePDFBoard(board, intl, breakPage);\n    return prevContent.concat(boardPDFData);\n  }, Promise.resolve([]));\n\n  docDefinition.content = content;\n  const pdfObj = pdfMake.createPdf(docDefinition);\n\n  if (pdfObj) {\n    let prefix = getDatetimePrefix();\n    if (content.length === 2) {\n      prefix = prefix + content[0] + ' ';\n    } else {\n      prefix = prefix + 'boardsset ';\n    }\n    if (isAndroid()) {\n      requestCvaWritePermissions();\n      pdfObj.getBuffer(buffer => {\n        var blob = new Blob([buffer], { type: 'application/pdf' });\n        const name = 'Download/' + prefix + EXPORT_CONFIG_BY_TYPE.pdf.filename;\n        writeCvaFile(name, blob);\n      });\n    } else {\n      // On a browser simply use download!\n      pdfObj.download(prefix + EXPORT_CONFIG_BY_TYPE.pdf.filename);\n    }\n  }\n}\n\nexport default {\n  openboardExportAdapter,\n  cboardExportAdapter,\n  pdfExportAdapter\n};\n"],"sourceRoot":""}